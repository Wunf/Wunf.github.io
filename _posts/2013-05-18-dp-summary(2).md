---
layout: post
category : algorithem related
title : "DP问题总结（2）"
tagline: "复习并敦促自己"
tags : [dynamic programming, summary]
---
{% include JB/setup %}

上一篇因为刚搭好的站，想赶紧弄一篇文章出来别让站空着，于是写得急急忙忙。说是总结，其实更像是凭着以往印象硬是写了点，也没收集资料做些研究再下笔。写这段文字的作用还是告诫自己以后还是别干这种事了，凡事都应该做好充分的准备，俗话说不打无准备之仗嘛。我最后抽空把那10道题做了，还是起到了敦促自己的作用的，顿感欣慰。这篇文章就主要结合上一篇分享下这10道题的思路吧。
####the Triangle
	    5
	   2 4
	  3 4 5
	 4 7 7 8
	6 7 4 3 2
在数字金字塔中找到从顶部到底部的最大带权路径
这个问题上一篇文章中有提到，问题本身是个很好的递归结构，解题思路应该很清晰。这里为了节省空间，我开了一个一维数组存贮最优解。这样就要计算当前要求最优解左下和右下方最优解的下标。观察后发现左下方最优解的下标是当前解下标加上当前解所在金字塔层数。设所在层数为x, 当前下标为i
	该层第一个解下标为: (x^2 - x) / 2
	i > (x ^ 2 - x) / 2
	sqrt(2 * i + 1 / 4) + 1 / 2 >= x
	x = [sqrt(2 * i + 1 / 4) + 1 / 2]
得到左下下标为i + x，右下为i + x + 1。之后只要算好状态转换，问题就迎刃而解了。
####Run Fun
	if a < b and b < c, then w(a, b, c) returns: 
	w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) 
	otherwise it returns: 
	w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) 
这道题就是给好了状态转换方程，让我们来模拟下DP的过程。因为下标是三维的可能会造成不能抽象出一般的平面转换过程，那就想象成是三维空间里的递推。或者略过这个过程，直接套用公式，尝试递推方向。发现完全可以从第三个下标开始依次递推。那么就是一个简单三层循环就能得到最后的结果。
####Recaman's Sequence
	 am = am−1 − m if the rsulting am is positive and not already in the sequence, otherwise am = am−1 + m. 
	 0, 1, 3, 6, 2, 7, 13, 20, 12, 21, 11, 22, 10, 23, 9 ... 
这道题就是一个递推。我做的时候把已经得到的数放进STL的set里面，用的时候找一下，感觉跟DP思想没啥关系。这里可以用HASH表存算好的结果，只要表足够大不产生冲突就能很快得出结果，就有点DP的感觉了。
####World Cup Noise
这道题就是求n位二进制数有几个是没有相邻1的。可以看成是对字符串的处理，前一篇文章总结了找最优解的方法可以先看前n-1个字符。这里最优子问题就是n-1位二进制数有几个没有相邻1，这里就取最后一位为减去的那位，状态转换方程是
	F[i] = F[i - 1] * 2 - (F[i - 1]中以1结尾的数个数)
	(F[i - 1]中以1结尾的数个数) = F[i - 2] -  (F[i - 2]中以1结尾的数个数)
####Common Subsequence
LCS是经典DP问题，有很多精彩的讲解，这里就不多说了。我觉得有的算法就算清楚地知道思路还是应该去实现下，才会有个更深切的认识。
####Compromise
这题是LCS的一个变种，题目简单描述下就是把LCS中的字符串换成句子，字符换成单词。要求输出最大公共子串，就要在状态转换的过程中做好标记，好在最后得到解的时候逆推得出问题最优解。具体方法算法导论中图解地很清楚。
####Palindrome
给一个字符串最少插几个字符变成回文。这题我还是试着自己思考了下的，但是最后还是缴枪投降找算法去了。遇到这种没思路的问题就很头疼，想么想了半天，最后又是从别人那里看的方法。所以我果断回去拿这题恶心室友去了。简单讲讲我的错误思考过程，引以为戒。拿到题，因为知道是跟DP有关系的题（这也算小作弊了），还是想是不是可以分解成子串做处理。又使出n-1大法，发现好像这个问题跟n-1子串确实没什么关系。然后因为跟回文有关，就想到把字符串二等分以及延长一倍等，但是依然没有结果。这里我觉得我是太缺乏推理的意愿了，拿到题就进行广度搜索，没有进一步分析问题的实质的想法，必须引以为戒。我想作为文章的话写到这里就可以了，如果真的有人对这个方法感兴趣可以思考下。
	hint1 : 跟DP有关
	hint2 : 需要对问题进行推理
####Human Gene Functions
依然是LCS的变种，题目很长，讲地很多，但是只是在状态转换的时候判断需要多写几步而已，这题不推荐尝试。
####Zipper
	String A: cat 
	String B: tree 
	String C: tcraete 
判断字符串C能不能由A和B插接而成
n-1大法，C的n-1子串能不能由A,B的连续子串插接而成，然后由第n个字符递推最后解。状态边界的初始化自己判断，然后状态转换方程
	F[j][k] = (C[j + k - 1] == A[j - 1] && F[j - 1][k]) || (C[j + k - 1] == B[k - 1] && F[j][k - 1])
其中F的两个维度是A和B的长度，因为最后只要判断能或者否，所以存的是BOOL型。
####Polygon
![image](http://poj.org/images/1179_1.jpg)

删一条边，然后以任意加括号顺序计算多项式，求最大结果。说到加括号，就可以判断出这题是矩阵链乘问题的一个变种，至于删哪条边只能枚举处理了。还有因为乘法的特殊性，最大值可能由最小值参与乘法得到，所以必须保存两组状态。因为这个我贡献了两个WA。具体解题方法可以参考矩阵链乘法。
####结语
这几天抽空做题发现还是挺好玩的，尤其是有思路的时候。比较鄙视回文那道题，让我耿耿于怀很久。还是那句话，算法还是应该多练多接触，熟读唐诗三百首，不会作诗也会吟。与君共勉。
